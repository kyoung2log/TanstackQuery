### Caching

예제를 통해 네가지 상황과 라이브 사이클을 살펴보자

- 캐시 데이터가 있는 인스턴스, 캐시 데이터가 없는 인스턴스
- 백그라운드 리페치
- 비활성화 쿼리
- 가비지 컬렉션

**기본 예제 : `gcTime 5분`, `staleTime 0`**

- `useQuery({ queryKey: ['todos'], queryFn: fetchTodos })` 의 새로운 인스턴스가 마운트 된다.

  -> 다른 쿼리들은 `['todos']` 키로 만들어진적이 없음. 즉 초기 요청이므로 쿼리는 loading 상태를 보여주고 데이터 페칭 요청(네트워크 요청)을 함

  -> 네트워크 요청이 완료되면 반환된 데이터는 `['todos']` 키 아래에 캐싱된다.

  -> 이 훅(`useQuery`)은 설정 `staleTime`이 지나면 데이터를 `stale` 상태로 표시함

- `useQuery({ queryKey: ['todos'], queryFn: fetchTodos })`의 두번째 인스턴스가 다른곳에서 마운트 됨

  -> 캐시는 `['todos']` 키에 대한 데이터를 이미 갖고 있기 때문에 데이터는 캐시에서 바로 반환됨

  -> 새로운 인스턴스는 백그라운드에서 새로운 네트워크 요청을 트리거 한다. 이 때 두 `fetchTodos` 쿼리 함수가 같든 다르든 상관없이 쿼리의 상태는 둘 다 업데이트 된다. 왜냐하면 같은 쿼리키를 가졌기 때문

  -> 요청이 성공적으로 완료되면, `['todos']` 키 아래의 캐시데이터는 새로운 데이터로 업데이트 되고, 두 인스턴스 모두 새로운 데이터로 업데이트 된다.

- 두 개의 인스턴스 모두 언마운트되고, 더 이상 사용되지 않게됨.

  -> 이 쿼리의 활성 인스턴스가 없기 때문에, 가비지 수거&삭제를 위해 가비지 컬렉션 타임아웃이 `gcTime`으로 세팅된다.

- 캐시타임아웃이 완료되기 전에 같은 쿼리키를 가지는 또 다른 인스턴스가 마운트되면, 쿼리는 캐시데이터를 반환하고 백그라운드에서 네트워크 요청을 보낸다.

  -> 네트워크 요청이 성공적으로 완료되면, 캐시에 새로운 데이터가 채워진다.

- 마지막 인스턴스가 언마운트되고, 5분 이내에 `['todos']` 키를 가지는 새로운 인스턴스가 나타나지 않는다면 `['todos']` 키 아래의 캐시데이터는 가바지컬렉터에 의해 삭제된다.
