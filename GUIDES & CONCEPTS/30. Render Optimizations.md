### Render Optimizations

리액트 쿼리는 컴포넌트가 실제로 필요할 때만 리렌더링 되도록 보장하기 위해서 여러가지 최적화를 자동으로 적용함. 아래는 여러가지 최적화 방법이다.

**구조적 공유(structural sharing)**

리액트 쿼리는 리렌더링이 발생할 때 가능한 많은 참조가 손상되지 않고 유지될 수 있게 구조적 공유라는 기술을 사용한다. 만약 네트워크를 통해 데이터를 가져왔다면, 보통 json을 파싱하고 완전히 새로운 참조를 갖게된다. 하지만 리액트 쿼리는 내부 데이터가 바뀌지 않았다면 오리지널 참조를 유지한다. 만약 부분적으로 바뀐 데이터가 있다면, 리액트는 바뀌지 않은 부분은 유지하고, 바뀐 부분만 업데이트한다.

이 최적화는 오직 queryFn이 json 형태의 데이터를 리턴했을 경우만 동작한다. 글로벌이나 쿼리별 설정에서 구조적 공유 옵션을 끌 수 있고, 직접 구현해도 된다.

**참조 정체성(referential identity)**

useQuery가 반환한 최상위 객체의 참조값은 안정적이지 않음(useInfiniteQuery, useMutation, useQueries도 마찬가지)

```js
const result = useQuery(...)

useEffect(() => {

}, [result])
```

그래서 위처럼 리턴된 객체를 그대로 사용하면 `result`의 참조값은 계속 바뀌기 때문에 안정적이지 않음

하지만 내부의 `data` 속성은 안정적이다.

```js
const { data } = useQuery(...)

useEffect(() => {

}, [data])
```

그래서 이렇게 쓰면 내부의 `data` 값은 내용이 같다면 이전 참조를 유지하기 때문에 안정적으로 사용할 수 있음

이게 어떻게 가능한가 ?

- 구조적 공유 기법으로 구현되어 변경된 부분만 교체를 하기 때문

왜 이렇게 설계했을까 ?

- 리액트는 변화를 감지할 때 객체의 참조값으로 변경이 발생했는지, 아닌지를 판단한다. 실제 탄스택 쿼리에서는 useSyncExternalStore를 사용해 리렌더를 트리거 하는데 이 때 참조값이 매번 같으면 렌더링이 트리거되지 않기 때문에 useQuery 같은 훅들은 항상 새로운 참조값을 리턴한다. 하지만 내부 데이터는 동일하게 유지됨 어떻게 ? 구조적 공유 기법으로! 그래서 새로운 객체를 리턴하면서도 데이터는 유지할 수 있어 최적화를 함

- 참조 정체성 느낀점 : 탄스택쿼리 구현의 가장 base기법이라고 생각.. 생태를 완전히 이해하려면 코드를 분석해보는 것이 빠를듯

**속성을 트래킹함(tracked properties)**

리액트 쿼리는 useQuery로부터 리턴된 속성 중 실제로 사용된 속성만 렌더링을 트리거 한다. 이것은 프록시 객체로부터 수행되는데, 이 덕분에 많은 불필요한 리렌더링을 피할 수 있다. 왜냐하면 isFetching, isStale같은 속성은 자주 바뀔 수 있지만 컴포넌트에선 사용되지 않을 수 있기 때문이다.

전역이나 각각의 쿼리의 세팅에서 notifyOnChangeProps 옵션을 통해 수동으로 커스텀 할 수 있다. 만약 이 기능을 끄길 원한다면 notifyOnChangeProps: 'all'로 설정하며 됨.

프록시 객체의 get 트랩은 구조분해 할당이나 직접 접근을 통해서 프로퍼티에 접근할 때 실행된다. 만약 나머지 구조분해할당을 통해 객체를 사용한다면 이 최적화가 무력화 된다. 린트를 참고해보셈

ㅊ

select 옵션을 사용해서 컴포넌트가 구독하는 데이터의 일부를 선택할 수 있다.
이건 데이터변환을 최적화하거나, 불필요한 리런데링을 피할 때 유용하다.

```js
export const useTodos = (select) => {
  return useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
    select,
  });
};

export const useTodoCount = () => {
  return useTodos((data) => data.length);
};
```

위 코드에서 컴포넌트는 useTodoCount라는 오직 todos의 길이가 변경될 때만 리렌더링이 발생하는 커스텀 훅을 사용한다.

이 select 옵션은 성공적으로 캐싱된 데이터에 대해서만 동작한다. 그리고 select는 에러를 던지기 적절한 장소가 아님.select에서 에러를 던지면 데이터는 undefined인데 성공상태가 되는 이상한 상황이 발생하니 에러가 실제로 발생하는 queryFn에서 핸들링 하거라

**memoization**

셀렉트 함수는 아래와 같은 상황에서 재실행 된다.

- 셀렉트 함수가 자체가 참조적으로 변경된 경우
- 데이터가 바뀐 경우

그래서 셀렉트 함수는 useCallback으로 한번 감싸거나, 종속성이 없는 외부 함수로 추출해서 참조값을 일관적으로 유지한다.
